// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: loot_table_entries.sql

package generated

import (
	"context"
)

const createLootTableEntry = `-- name: CreateLootTableEntry :one
INSERT INTO loot_table_entries (loot_table_id, cosmetic_id, weight, min_quantity, max_quantity)
VALUES (?, ?, ?, ?, ?)
RETURNING loot_entry_id, loot_table_id, cosmetic_id, weight, min_quantity, max_quantity
`

type CreateLootTableEntryParams struct {
	LootTableID int64 `json:"loot_table_id"`
	CosmeticID  int64 `json:"cosmetic_id"`
	Weight      int64 `json:"weight"`
	MinQuantity int64 `json:"min_quantity"`
	MaxQuantity int64 `json:"max_quantity"`
}

func (q *Queries) CreateLootTableEntry(ctx context.Context, db DBTX, arg *CreateLootTableEntryParams) (*LootTableEntry, error) {
	row := db.QueryRowContext(ctx, createLootTableEntry,
		arg.LootTableID,
		arg.CosmeticID,
		arg.Weight,
		arg.MinQuantity,
		arg.MaxQuantity,
	)
	var i LootTableEntry
	err := row.Scan(
		&i.LootEntryID,
		&i.LootTableID,
		&i.CosmeticID,
		&i.Weight,
		&i.MinQuantity,
		&i.MaxQuantity,
	)
	return &i, err
}

const deleteLootTableEntry = `-- name: DeleteLootTableEntry :exec
DELETE FROM loot_table_entries
WHERE loot_entry_id = ?
`

func (q *Queries) DeleteLootTableEntry(ctx context.Context, db DBTX, lootEntryID int64) error {
	_, err := db.ExecContext(ctx, deleteLootTableEntry, lootEntryID)
	return err
}

const getLootTableEntriesByLootTableID = `-- name: GetLootTableEntriesByLootTableID :many
SELECT loot_entry_id, loot_table_id, cosmetic_id, weight, min_quantity, max_quantity FROM loot_table_entries
WHERE loot_table_id = ?
ORDER BY loot_entry_id
`

func (q *Queries) GetLootTableEntriesByLootTableID(ctx context.Context, db DBTX, lootTableID int64) ([]*LootTableEntry, error) {
	rows, err := db.QueryContext(ctx, getLootTableEntriesByLootTableID, lootTableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LootTableEntry{}
	for rows.Next() {
		var i LootTableEntry
		if err := rows.Scan(
			&i.LootEntryID,
			&i.LootTableID,
			&i.CosmeticID,
			&i.Weight,
			&i.MinQuantity,
			&i.MaxQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLootTableEntriesWithCosmeticDetails = `-- name: GetLootTableEntriesWithCosmeticDetails :many
SELECT lte.loot_entry_id, lte.loot_table_id, lte.cosmetic_id, lte.weight, lte.min_quantity, lte.max_quantity, ci.name AS cosmetic_name, ci.rarity AS cosmetic_rarity, ci.slot AS cosmetic_slot
FROM loot_table_entries lte
JOIN cosmetic_items ci ON lte.cosmetic_id = ci.cosmetic_id
WHERE lte.loot_table_id = ?
ORDER BY lte.loot_entry_id
`

type GetLootTableEntriesWithCosmeticDetailsRow struct {
	LootEntryID    int64  `json:"loot_entry_id"`
	LootTableID    int64  `json:"loot_table_id"`
	CosmeticID     int64  `json:"cosmetic_id"`
	Weight         int64  `json:"weight"`
	MinQuantity    int64  `json:"min_quantity"`
	MaxQuantity    int64  `json:"max_quantity"`
	CosmeticName   string `json:"cosmetic_name"`
	CosmeticRarity string `json:"cosmetic_rarity"`
	CosmeticSlot   string `json:"cosmetic_slot"`
}

func (q *Queries) GetLootTableEntriesWithCosmeticDetails(ctx context.Context, db DBTX, lootTableID int64) ([]*GetLootTableEntriesWithCosmeticDetailsRow, error) {
	rows, err := db.QueryContext(ctx, getLootTableEntriesWithCosmeticDetails, lootTableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLootTableEntriesWithCosmeticDetailsRow{}
	for rows.Next() {
		var i GetLootTableEntriesWithCosmeticDetailsRow
		if err := rows.Scan(
			&i.LootEntryID,
			&i.LootTableID,
			&i.CosmeticID,
			&i.Weight,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.CosmeticName,
			&i.CosmeticRarity,
			&i.CosmeticSlot,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLootTableEntry = `-- name: GetLootTableEntry :one
SELECT loot_entry_id, loot_table_id, cosmetic_id, weight, min_quantity, max_quantity FROM loot_table_entries
WHERE loot_entry_id = ?
`

func (q *Queries) GetLootTableEntry(ctx context.Context, db DBTX, lootEntryID int64) (*LootTableEntry, error) {
	row := db.QueryRowContext(ctx, getLootTableEntry, lootEntryID)
	var i LootTableEntry
	err := row.Scan(
		&i.LootEntryID,
		&i.LootTableID,
		&i.CosmeticID,
		&i.Weight,
		&i.MinQuantity,
		&i.MaxQuantity,
	)
	return &i, err
}

const updateLootTableEntry = `-- name: UpdateLootTableEntry :exec
UPDATE loot_table_entries
SET loot_table_id = ?, cosmetic_id = ?, weight = ?, min_quantity = ?, max_quantity = ?
WHERE loot_entry_id = ?
`

type UpdateLootTableEntryParams struct {
	LootTableID int64 `json:"loot_table_id"`
	CosmeticID  int64 `json:"cosmetic_id"`
	Weight      int64 `json:"weight"`
	MinQuantity int64 `json:"min_quantity"`
	MaxQuantity int64 `json:"max_quantity"`
	LootEntryID int64 `json:"loot_entry_id"`
}

func (q *Queries) UpdateLootTableEntry(ctx context.Context, db DBTX, arg *UpdateLootTableEntryParams) error {
	_, err := db.ExecContext(ctx, updateLootTableEntry,
		arg.LootTableID,
		arg.CosmeticID,
		arg.Weight,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.LootEntryID,
	)
	return err
}
