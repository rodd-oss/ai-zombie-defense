// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package generated

import (
	"context"

	"ai-zombie-defense/backend-api/internal/db/types"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    server_id,
    map_name,
    game_mode,
    start_time,
    end_time,
    outcome,
    waves_survived,
    total_zombies_killed,
    total_players
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING match_id, server_id, map_name, game_mode, start_time, end_time, outcome, waves_survived, total_zombies_killed, total_players
`

type CreateMatchParams struct {
	ServerID           int64               `json:"server_id"`
	MapName            string              `json:"map_name"`
	GameMode           string              `json:"game_mode"`
	StartTime          types.Timestamp     `json:"start_time"`
	EndTime            types.NullTimestamp `json:"end_time"`
	Outcome            string              `json:"outcome"`
	WavesSurvived      int64               `json:"waves_survived"`
	TotalZombiesKilled int64               `json:"total_zombies_killed"`
	TotalPlayers       int64               `json:"total_players"`
}

func (q *Queries) CreateMatch(ctx context.Context, db DBTX, arg *CreateMatchParams) (*Match, error) {
	row := db.QueryRowContext(ctx, createMatch,
		arg.ServerID,
		arg.MapName,
		arg.GameMode,
		arg.StartTime,
		arg.EndTime,
		arg.Outcome,
		arg.WavesSurvived,
		arg.TotalZombiesKilled,
		arg.TotalPlayers,
	)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.ServerID,
		&i.MapName,
		&i.GameMode,
		&i.StartTime,
		&i.EndTime,
		&i.Outcome,
		&i.WavesSurvived,
		&i.TotalZombiesKilled,
		&i.TotalPlayers,
	)
	return &i, err
}

const getMatch = `-- name: GetMatch :one
SELECT match_id, server_id, map_name, game_mode, start_time, end_time, outcome, waves_survived, total_zombies_killed, total_players FROM matches WHERE match_id = ?
`

func (q *Queries) GetMatch(ctx context.Context, db DBTX, matchID int64) (*Match, error) {
	row := db.QueryRowContext(ctx, getMatch, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.ServerID,
		&i.MapName,
		&i.GameMode,
		&i.StartTime,
		&i.EndTime,
		&i.Outcome,
		&i.WavesSurvived,
		&i.TotalZombiesKilled,
		&i.TotalPlayers,
	)
	return &i, err
}

const getPlayerMatchHistory = `-- name: GetPlayerMatchHistory :many
SELECT 
    m.match_id, m.server_id, m.map_name, m.game_mode, m.start_time, m.end_time, m.outcome, m.waves_survived, m.total_zombies_killed, m.total_players,
    pms.waves_survived as player_waves_survived,
    pms.zombies_killed as player_zombies_killed,
    pms.deaths as player_deaths,
    pms.scrap_earned as player_scrap_earned,
    pms.data_earned as player_data_earned,
    pms.damage_dealt as player_damage_dealt,
    pms.damage_taken as player_damage_taken,
    pms.buildings_built as player_buildings_built,
    pms.buildings_destroyed as player_buildings_destroyed,
    pms.healing_given as player_healing_given,
    pms.revives as player_revives,
    pms.score as player_score
FROM matches m
JOIN player_match_stats pms ON m.match_id = pms.match_id
WHERE pms.player_id = ?
ORDER BY m.start_time DESC
LIMIT ?
`

type GetPlayerMatchHistoryParams struct {
	PlayerID int64 `json:"player_id"`
	Limit    int64 `json:"limit"`
}

type GetPlayerMatchHistoryRow struct {
	MatchID                  int64               `json:"match_id"`
	ServerID                 int64               `json:"server_id"`
	MapName                  string              `json:"map_name"`
	GameMode                 string              `json:"game_mode"`
	StartTime                types.Timestamp     `json:"start_time"`
	EndTime                  types.NullTimestamp `json:"end_time"`
	Outcome                  string              `json:"outcome"`
	WavesSurvived            int64               `json:"waves_survived"`
	TotalZombiesKilled       int64               `json:"total_zombies_killed"`
	TotalPlayers             int64               `json:"total_players"`
	PlayerWavesSurvived      int64               `json:"player_waves_survived"`
	PlayerZombiesKilled      int64               `json:"player_zombies_killed"`
	PlayerDeaths             int64               `json:"player_deaths"`
	PlayerScrapEarned        int64               `json:"player_scrap_earned"`
	PlayerDataEarned         int64               `json:"player_data_earned"`
	PlayerDamageDealt        int64               `json:"player_damage_dealt"`
	PlayerDamageTaken        int64               `json:"player_damage_taken"`
	PlayerBuildingsBuilt     int64               `json:"player_buildings_built"`
	PlayerBuildingsDestroyed int64               `json:"player_buildings_destroyed"`
	PlayerHealingGiven       int64               `json:"player_healing_given"`
	PlayerRevives            int64               `json:"player_revives"`
	PlayerScore              int64               `json:"player_score"`
}

func (q *Queries) GetPlayerMatchHistory(ctx context.Context, db DBTX, arg *GetPlayerMatchHistoryParams) ([]*GetPlayerMatchHistoryRow, error) {
	rows, err := db.QueryContext(ctx, getPlayerMatchHistory, arg.PlayerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlayerMatchHistoryRow{}
	for rows.Next() {
		var i GetPlayerMatchHistoryRow
		if err := rows.Scan(
			&i.MatchID,
			&i.ServerID,
			&i.MapName,
			&i.GameMode,
			&i.StartTime,
			&i.EndTime,
			&i.Outcome,
			&i.WavesSurvived,
			&i.TotalZombiesKilled,
			&i.TotalPlayers,
			&i.PlayerWavesSurvived,
			&i.PlayerZombiesKilled,
			&i.PlayerDeaths,
			&i.PlayerScrapEarned,
			&i.PlayerDataEarned,
			&i.PlayerDamageDealt,
			&i.PlayerDamageTaken,
			&i.PlayerBuildingsBuilt,
			&i.PlayerBuildingsDestroyed,
			&i.PlayerHealingGiven,
			&i.PlayerRevives,
			&i.PlayerScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchOutcome = `-- name: UpdateMatchOutcome :exec
UPDATE matches
SET outcome = ?, end_time = ?
WHERE match_id = ?
`

type UpdateMatchOutcomeParams struct {
	Outcome string              `json:"outcome"`
	EndTime types.NullTimestamp `json:"end_time"`
	MatchID int64               `json:"match_id"`
}

func (q *Queries) UpdateMatchOutcome(ctx context.Context, db DBTX, arg *UpdateMatchOutcomeParams) error {
	_, err := db.ExecContext(ctx, updateMatchOutcome, arg.Outcome, arg.EndTime, arg.MatchID)
	return err
}
