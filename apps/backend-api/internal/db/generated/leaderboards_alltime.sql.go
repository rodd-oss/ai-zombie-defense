// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: leaderboards_alltime.sql

package generated

import (
	"context"
)

const getAllTimeLeaderboard = `-- name: GetAllTimeLeaderboard :many
SELECT
  p.player_id,
  p.username,
  CAST(SUM(pms.score) AS INTEGER) AS total_score,
  COUNT(pms.match_id) AS matches_played,
  AVG(pms.zombies_killed) AS avg_kills_per_match,
  AVG(pms.waves_survived) AS avg_waves_survived,
  CAST(ROW_NUMBER() OVER (ORDER BY SUM(pms.score) DESC) AS INTEGER) AS ranking
FROM player_match_stats pms
JOIN players p ON pms.player_id = p.player_id
GROUP BY pms.player_id
ORDER BY total_score DESC
`

type GetAllTimeLeaderboardRow struct {
	PlayerID         int64    `json:"player_id"`
	Username         string   `json:"username"`
	TotalScore       int64    `json:"total_score"`
	MatchesPlayed    int64    `json:"matches_played"`
	AvgKillsPerMatch *float64 `json:"avg_kills_per_match"`
	AvgWavesSurvived *float64 `json:"avg_waves_survived"`
	Ranking          int64    `json:"ranking"`
}

func (q *Queries) GetAllTimeLeaderboard(ctx context.Context, db DBTX) ([]*GetAllTimeLeaderboardRow, error) {
	rows, err := db.QueryContext(ctx, getAllTimeLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllTimeLeaderboardRow{}
	for rows.Next() {
		var i GetAllTimeLeaderboardRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Username,
			&i.TotalScore,
			&i.MatchesPlayed,
			&i.AvgKillsPerMatch,
			&i.AvgWavesSurvived,
			&i.Ranking,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
