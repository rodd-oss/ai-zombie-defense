// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: friends.sql

package db

import (
	"context"

	"ai-zombie-defense/backend-api/db/types"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :exec
UPDATE friends 
SET status = 'accepted', updated_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
WHERE player_id = ?1 AND friend_id = ?2 AND status = 'pending'
`

type AcceptFriendRequestParams struct {
	PlayerID int64 `json:"player_id"`
	FriendID int64 `json:"friend_id"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, db DBTX, arg *AcceptFriendRequestParams) error {
	_, err := db.ExecContext(ctx, acceptFriendRequest, arg.PlayerID, arg.FriendID)
	return err
}

const createFriendRequest = `-- name: CreateFriendRequest :exec
INSERT INTO friends (player_id, friend_id, status) VALUES (?1, ?2, 'pending')
`

type CreateFriendRequestParams struct {
	PlayerID int64 `json:"player_id"`
	FriendID int64 `json:"friend_id"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, db DBTX, arg *CreateFriendRequestParams) error {
	_, err := db.ExecContext(ctx, createFriendRequest, arg.PlayerID, arg.FriendID)
	return err
}

const declineFriendRequest = `-- name: DeclineFriendRequest :exec
DELETE FROM friends 
WHERE player_id = ?1 AND friend_id = ?2 AND status = 'pending'
`

type DeclineFriendRequestParams struct {
	PlayerID int64 `json:"player_id"`
	FriendID int64 `json:"friend_id"`
}

func (q *Queries) DeclineFriendRequest(ctx context.Context, db DBTX, arg *DeclineFriendRequestParams) error {
	_, err := db.ExecContext(ctx, declineFriendRequest, arg.PlayerID, arg.FriendID)
	return err
}

const getFriendRequest = `-- name: GetFriendRequest :one
SELECT player_id, friend_id, status, created_at, updated_at FROM friends WHERE player_id = ?1 AND friend_id = ?2
`

type GetFriendRequestParams struct {
	PlayerID int64 `json:"player_id"`
	FriendID int64 `json:"friend_id"`
}

func (q *Queries) GetFriendRequest(ctx context.Context, db DBTX, arg *GetFriendRequestParams) (*Friend, error) {
	row := db.QueryRowContext(ctx, getFriendRequest, arg.PlayerID, arg.FriendID)
	var i Friend
	err := row.Scan(
		&i.PlayerID,
		&i.FriendID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listFriends = `-- name: ListFriends :many
SELECT 
  CAST(CASE 
    WHEN f.player_id = ?1 THEN f.friend_id 
    ELSE f.player_id 
  END AS INTEGER) AS friend_player_id,
  p.username AS friend_username,
  f.status,
  f.created_at,
  f.updated_at
FROM friends f
JOIN players p ON p.player_id = CAST(CASE 
    WHEN f.player_id = ?1 THEN f.friend_id 
    ELSE f.player_id 
  END AS INTEGER)
WHERE (f.player_id = ?1 OR f.friend_id = ?1) AND f.status = 'accepted'
`

type ListFriendsRow struct {
	FriendPlayerID int64           `json:"friend_player_id"`
	FriendUsername string          `json:"friend_username"`
	Status         string          `json:"status"`
	CreatedAt      types.Timestamp `json:"created_at"`
	UpdatedAt      types.Timestamp `json:"updated_at"`
}

func (q *Queries) ListFriends(ctx context.Context, db DBTX, playerID int64) ([]*ListFriendsRow, error) {
	rows, err := db.QueryContext(ctx, listFriends, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListFriendsRow{}
	for rows.Next() {
		var i ListFriendsRow
		if err := rows.Scan(
			&i.FriendPlayerID,
			&i.FriendUsername,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingIncoming = `-- name: ListPendingIncoming :many
SELECT f.player_id AS requester_player_id, p.username AS requester_username, f.created_at
FROM friends f
JOIN players p ON f.player_id = p.player_id
WHERE f.friend_id = ?1 AND f.status = 'pending'
`

type ListPendingIncomingRow struct {
	RequesterPlayerID int64           `json:"requester_player_id"`
	RequesterUsername string          `json:"requester_username"`
	CreatedAt         types.Timestamp `json:"created_at"`
}

func (q *Queries) ListPendingIncoming(ctx context.Context, db DBTX, friendID int64) ([]*ListPendingIncomingRow, error) {
	rows, err := db.QueryContext(ctx, listPendingIncoming, friendID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPendingIncomingRow{}
	for rows.Next() {
		var i ListPendingIncomingRow
		if err := rows.Scan(&i.RequesterPlayerID, &i.RequesterUsername, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOutgoing = `-- name: ListPendingOutgoing :many
SELECT f.friend_id AS target_player_id, p.username AS target_username, f.created_at
FROM friends f
JOIN players p ON f.friend_id = p.player_id
WHERE f.player_id = ?1 AND f.status = 'pending'
`

type ListPendingOutgoingRow struct {
	TargetPlayerID int64           `json:"target_player_id"`
	TargetUsername string          `json:"target_username"`
	CreatedAt      types.Timestamp `json:"created_at"`
}

func (q *Queries) ListPendingOutgoing(ctx context.Context, db DBTX, playerID int64) ([]*ListPendingOutgoingRow, error) {
	rows, err := db.QueryContext(ctx, listPendingOutgoing, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPendingOutgoingRow{}
	for rows.Next() {
		var i ListPendingOutgoingRow
		if err := rows.Scan(&i.TargetPlayerID, &i.TargetUsername, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
