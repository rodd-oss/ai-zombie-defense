// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cosmetic_items.sql

package db

import (
	"context"
)

const getPrestigeCosmetics = `-- name: GetPrestigeCosmetics :many
SELECT ci.cosmetic_id, ci.name, ci.description, ci.slot, ci.category, ci.rarity, ci.unlock_level, ci.data_cost, ci.is_prestige_only, ci.created_at FROM cosmetic_items ci
LEFT JOIN player_cosmetics pc ON ci.cosmetic_id = pc.cosmetic_id AND pc.player_id = ?1
WHERE ci.is_prestige_only = 1
    AND ci.unlock_level <= ?2
    AND pc.cosmetic_id IS NULL
`

type GetPrestigeCosmeticsParams struct {
	PlayerID    int64 `json:"player_id"`
	UnlockLevel int64 `json:"unlock_level"`
}

func (q *Queries) GetPrestigeCosmetics(ctx context.Context, db DBTX, arg *GetPrestigeCosmeticsParams) ([]*CosmeticItem, error) {
	rows, err := db.QueryContext(ctx, getPrestigeCosmetics, arg.PlayerID, arg.UnlockLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CosmeticItem{}
	for rows.Next() {
		var i CosmeticItem
		if err := rows.Scan(
			&i.CosmeticID,
			&i.Name,
			&i.Description,
			&i.Slot,
			&i.Category,
			&i.Rarity,
			&i.UnlockLevel,
			&i.DataCost,
			&i.IsPrestigeOnly,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const grantCosmeticToPlayer = `-- name: GrantCosmeticToPlayer :exec
INSERT INTO player_cosmetics (player_id, cosmetic_id, unlocked_via)
VALUES (?, ?, ?)
`

type GrantCosmeticToPlayerParams struct {
	PlayerID    int64  `json:"player_id"`
	CosmeticID  int64  `json:"cosmetic_id"`
	UnlockedVia string `json:"unlocked_via"`
}

func (q *Queries) GrantCosmeticToPlayer(ctx context.Context, db DBTX, arg *GrantCosmeticToPlayerParams) error {
	_, err := db.ExecContext(ctx, grantCosmeticToPlayer, arg.PlayerID, arg.CosmeticID, arg.UnlockedVia)
	return err
}
