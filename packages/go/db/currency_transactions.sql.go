// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: currency_transactions.sql

package db

import (
	"context"
)

const countCurrencyTransactionsByPlayer = `-- name: CountCurrencyTransactionsByPlayer :one
SELECT COUNT(*) FROM currency_transactions WHERE player_id = ?
`

func (q *Queries) CountCurrencyTransactionsByPlayer(ctx context.Context, db DBTX, playerID int64) (int64, error) {
	row := db.QueryRowContext(ctx, countCurrencyTransactionsByPlayer, playerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCurrencyTransaction = `-- name: CreateCurrencyTransaction :exec
INSERT INTO currency_transactions (player_id, amount, balance_after, transaction_type, reference_id)
VALUES (?, ?, ?, ?, ?)
`

type CreateCurrencyTransactionParams struct {
	PlayerID        int64  `json:"player_id"`
	Amount          int64  `json:"amount"`
	BalanceAfter    int64  `json:"balance_after"`
	TransactionType string `json:"transaction_type"`
	ReferenceID     *int64 `json:"reference_id"`
}

func (q *Queries) CreateCurrencyTransaction(ctx context.Context, db DBTX, arg *CreateCurrencyTransactionParams) error {
	_, err := db.ExecContext(ctx, createCurrencyTransaction,
		arg.PlayerID,
		arg.Amount,
		arg.BalanceAfter,
		arg.TransactionType,
		arg.ReferenceID,
	)
	return err
}

const getCurrencyTransactionsByPlayer = `-- name: GetCurrencyTransactionsByPlayer :many
SELECT transaction_id, player_id, amount, balance_after, transaction_type, reference_id, created_at FROM currency_transactions WHERE player_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type GetCurrencyTransactionsByPlayerParams struct {
	PlayerID int64 `json:"player_id"`
	Limit    int64 `json:"limit"`
	Offset   int64 `json:"offset"`
}

func (q *Queries) GetCurrencyTransactionsByPlayer(ctx context.Context, db DBTX, arg *GetCurrencyTransactionsByPlayerParams) ([]*CurrencyTransaction, error) {
	rows, err := db.QueryContext(ctx, getCurrencyTransactionsByPlayer, arg.PlayerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CurrencyTransaction{}
	for rows.Next() {
		var i CurrencyTransaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.PlayerID,
			&i.Amount,
			&i.BalanceAfter,
			&i.TransactionType,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrencyTransactionsByPlayerAndType = `-- name: GetCurrencyTransactionsByPlayerAndType :many
SELECT transaction_id, player_id, amount, balance_after, transaction_type, reference_id, created_at FROM currency_transactions WHERE player_id = ? AND transaction_type = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type GetCurrencyTransactionsByPlayerAndTypeParams struct {
	PlayerID        int64  `json:"player_id"`
	TransactionType string `json:"transaction_type"`
	Limit           int64  `json:"limit"`
	Offset          int64  `json:"offset"`
}

func (q *Queries) GetCurrencyTransactionsByPlayerAndType(ctx context.Context, db DBTX, arg *GetCurrencyTransactionsByPlayerAndTypeParams) ([]*CurrencyTransaction, error) {
	rows, err := db.QueryContext(ctx, getCurrencyTransactionsByPlayerAndType,
		arg.PlayerID,
		arg.TransactionType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CurrencyTransaction{}
	for rows.Next() {
		var i CurrencyTransaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.PlayerID,
			&i.Amount,
			&i.BalanceAfter,
			&i.TransactionType,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
