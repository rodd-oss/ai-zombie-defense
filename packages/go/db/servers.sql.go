// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: servers.sql

package db

import (
	"context"
)

const createServer = `-- name: CreateServer :one
INSERT INTO servers (
    ip_address,
    port,
    auth_token,
    name,
    map_rotation,
    max_players,
    region,
    version
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING server_id, ip_address, port, auth_token, name, map_rotation, max_players, current_players, is_online, last_heartbeat, region, version, created_at
`

type CreateServerParams struct {
	IpAddress   string  `json:"ip_address"`
	Port        int64   `json:"port"`
	AuthToken   *string `json:"auth_token"`
	Name        string  `json:"name"`
	MapRotation *string `json:"map_rotation"`
	MaxPlayers  int64   `json:"max_players"`
	Region      *string `json:"region"`
	Version     *string `json:"version"`
}

func (q *Queries) CreateServer(ctx context.Context, db DBTX, arg *CreateServerParams) (*Server, error) {
	row := db.QueryRowContext(ctx, createServer,
		arg.IpAddress,
		arg.Port,
		arg.AuthToken,
		arg.Name,
		arg.MapRotation,
		arg.MaxPlayers,
		arg.Region,
		arg.Version,
	)
	var i Server
	err := row.Scan(
		&i.ServerID,
		&i.IpAddress,
		&i.Port,
		&i.AuthToken,
		&i.Name,
		&i.MapRotation,
		&i.MaxPlayers,
		&i.CurrentPlayers,
		&i.IsOnline,
		&i.LastHeartbeat,
		&i.Region,
		&i.Version,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteServer = `-- name: DeleteServer :exec
DELETE FROM servers WHERE server_id = ?
`

func (q *Queries) DeleteServer(ctx context.Context, db DBTX, serverID int64) error {
	_, err := db.ExecContext(ctx, deleteServer, serverID)
	return err
}

const getServer = `-- name: GetServer :one
SELECT server_id, ip_address, port, auth_token, name, map_rotation, max_players, current_players, is_online, last_heartbeat, region, version, created_at FROM servers WHERE server_id = ?
`

func (q *Queries) GetServer(ctx context.Context, db DBTX, serverID int64) (*Server, error) {
	row := db.QueryRowContext(ctx, getServer, serverID)
	var i Server
	err := row.Scan(
		&i.ServerID,
		&i.IpAddress,
		&i.Port,
		&i.AuthToken,
		&i.Name,
		&i.MapRotation,
		&i.MaxPlayers,
		&i.CurrentPlayers,
		&i.IsOnline,
		&i.LastHeartbeat,
		&i.Region,
		&i.Version,
		&i.CreatedAt,
	)
	return &i, err
}

const getServerByAuthToken = `-- name: GetServerByAuthToken :one
SELECT server_id, ip_address, port, auth_token, name, map_rotation, max_players, current_players, is_online, last_heartbeat, region, version, created_at FROM servers WHERE auth_token = ?
`

func (q *Queries) GetServerByAuthToken(ctx context.Context, db DBTX, authToken *string) (*Server, error) {
	row := db.QueryRowContext(ctx, getServerByAuthToken, authToken)
	var i Server
	err := row.Scan(
		&i.ServerID,
		&i.IpAddress,
		&i.Port,
		&i.AuthToken,
		&i.Name,
		&i.MapRotation,
		&i.MaxPlayers,
		&i.CurrentPlayers,
		&i.IsOnline,
		&i.LastHeartbeat,
		&i.Region,
		&i.Version,
		&i.CreatedAt,
	)
	return &i, err
}

const listActiveServers = `-- name: ListActiveServers :many
SELECT server_id, ip_address, port, auth_token, name, map_rotation, max_players, current_players, is_online, last_heartbeat, region, version, created_at FROM servers
WHERE is_online = 1
  AND (region = ?1 OR ?1 IS NULL)
  AND (map_rotation = ?2 OR ?2 IS NULL)
  AND (version = ?3 OR ?3 IS NULL)
  AND (current_players >= ?4 OR ?4 = -1)
  AND (current_players <= ?5 OR ?5 = -1)
ORDER BY server_id
`

type ListActiveServersParams struct {
	Region           *string `json:"region"`
	MapRotation      *string `json:"map_rotation"`
	Version          *string `json:"version"`
	CurrentPlayers   int64   `json:"current_players"`
	CurrentPlayers_2 int64   `json:"current_players_2"`
}

func (q *Queries) ListActiveServers(ctx context.Context, db DBTX, arg *ListActiveServersParams) ([]*Server, error) {
	rows, err := db.QueryContext(ctx, listActiveServers,
		arg.Region,
		arg.MapRotation,
		arg.Version,
		arg.CurrentPlayers,
		arg.CurrentPlayers_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Server{}
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ServerID,
			&i.IpAddress,
			&i.Port,
			&i.AuthToken,
			&i.Name,
			&i.MapRotation,
			&i.MaxPlayers,
			&i.CurrentPlayers,
			&i.IsOnline,
			&i.LastHeartbeat,
			&i.Region,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServers = `-- name: ListServers :many
SELECT server_id, ip_address, port, auth_token, name, map_rotation, max_players, current_players, is_online, last_heartbeat, region, version, created_at FROM servers ORDER BY server_id
`

func (q *Queries) ListServers(ctx context.Context, db DBTX) ([]*Server, error) {
	rows, err := db.QueryContext(ctx, listServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Server{}
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ServerID,
			&i.IpAddress,
			&i.Port,
			&i.AuthToken,
			&i.Name,
			&i.MapRotation,
			&i.MaxPlayers,
			&i.CurrentPlayers,
			&i.IsOnline,
			&i.LastHeartbeat,
			&i.Region,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markServerOffline = `-- name: MarkServerOffline :exec
UPDATE servers
SET is_online = 0
WHERE server_id = ?
`

func (q *Queries) MarkServerOffline(ctx context.Context, db DBTX, serverID int64) error {
	_, err := db.ExecContext(ctx, markServerOffline, serverID)
	return err
}

const updateServerHeartbeat = `-- name: UpdateServerHeartbeat :exec
UPDATE servers
SET last_heartbeat = ?, current_players = ?, is_online = 1, map_rotation = ?
WHERE server_id = ?
`

type UpdateServerHeartbeatParams struct {
	LastHeartbeat  *string `json:"last_heartbeat"`
	CurrentPlayers int64   `json:"current_players"`
	MapRotation    *string `json:"map_rotation"`
	ServerID       int64   `json:"server_id"`
}

func (q *Queries) UpdateServerHeartbeat(ctx context.Context, db DBTX, arg *UpdateServerHeartbeatParams) error {
	_, err := db.ExecContext(ctx, updateServerHeartbeat,
		arg.LastHeartbeat,
		arg.CurrentPlayers,
		arg.MapRotation,
		arg.ServerID,
	)
	return err
}
